run.feature.test=TRUE # process features for test set
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
label_train <- read.table(paste(experiment_dir, "train_label.txt", sep=""),
header=F)
label_train <- as.numeric(unlist(label_train) == "9")
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zipcode",
export=TRUE))
}
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
tm_feature_test <- NA
if(run.feature.test){
tm_feature_test <- system.time(dat_test <- feature(img_test_dir,
"test",
data_name="zip",
export=TRUE))
#save(dat_train, file="./output/feature_train.RData")
#save(dat_test, file="./output/feature_test.RData")
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
tm_feature_test <- NA
if(run.feature.test){
tm_feature_test <- system.time(dat_test <- feature(img_test_dir,
"test",
data_name="zip",
export=TRUE))
}
#save(dat_train, file="./output/feature_train.RData")
#save(dat_test, file="./output/feature_test.RData")
source("../lib/train.R")
source("../lib/test.R")
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(depth_values), 2))
for(k in 1:length(depth_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(depth_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
if(!require("EBImage")){
source("https://bioconductor.org/biocLite.R")
biocLite("EBImage")
}
if(!require("gbm")){
install.packages("gbm")
}
library("EBImage")
library("gbm")
experiment_dir <- "../data/zipcode/" # This will be modified for different data sets.
img_train_dir <- paste(experiment_dir, "train/", sep="")
img_test_dir <- paste(experiment_dir, "test/", sep="")
run.cv=TRUE # run cross-validation on the training set
K <- 5  # number of CV folds
run.feature.train=TRUE # process features for training set
run.test=TRUE # run evaluation on an independent test set
run.feature.test=TRUE # process features for test set
model_values <- seq(3, 11, 2)
model_labels = paste("GBM with depth =", model_values)
label_train <- read.table(paste(experiment_dir, "train_label.txt", sep=""),
header=F)
label_train <- as.numeric(unlist(label_train) == "9")
source("../lib/feature.R")
tm_feature_train <- NA
if(run.feature.train){
tm_feature_train <- system.time(dat_train <- feature(img_train_dir,
"train",
data_name="zip",
export=TRUE))
}
tm_feature_test <- NA
if(run.feature.test){
tm_feature_test <- system.time(dat_test <- feature(img_test_dir,
"test",
data_name="zip",
export=TRUE))
}
#save(dat_train, file="./output/feature_train.RData")
#save(dat_test, file="./output/feature_test.RData")
source("../lib/train.R")
source("../lib/test.R")
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
source("../lib/cross_validation.R")
if(run.cv){
err_cv <- array(dim=c(length(model_values), 2))
for(k in 1:length(model_values)){
cat("k=", k, "\n")
err_cv[k,] <- cv.function(dat_train, label_train, model_values[k], K)
}
save(err_cv, file="../output/err_cv.RData")
}
if(run.cv){
load("../output/err_cv.RData")
#pdf("../fig/cv_results.pdf", width=7, height=5)
plot(model_values, err_cv[,1], xlab="Interaction Depth", ylab="CV Error",
main="Cross Validation Error", type="n", ylim=c(0, 0.15))
points(model_values, err_cv[,1], col="blue", pch=16)
lines(model_values, err_cv[,1], col="blue")
arrows(model_values, err_cv[,1]-err_cv[,2],depth_values, err_cv[,1]+err_cv[,2],
length=0.1, angle=90, code=3)
#dev.off()
}
if(run.cv){
load("../output/err_cv.RData")
#pdf("../fig/cv_results.pdf", width=7, height=5)
plot(model_values, err_cv[,1], xlab="Interaction Depth", ylab="CV Error",
main="Cross Validation Error", type="n", ylim=c(0, 0.15))
points(model_values, err_cv[,1], col="blue", pch=16)
lines(model_values, err_cv[,1], col="blue")
arrows(model_values, err_cv[,1]-err_cv[,2], model_values, err_cv[,1]+err_cv[,2],
length=0.1, angle=90, code=3)
#dev.off()
}
if(run.cv){
load("../output/err_cv.RData")
#pdf("../fig/cv_results.pdf", width=7, height=5)
plot(model_values, err_cv[,1], xlab="Interaction Depth", ylab="CV Error",
main="Cross Validation Error", type="n", ylim=c(0, 0.25))
points(model_values, err_cv[,1], col="blue", pch=16)
lines(model_values, err_cv[,1], col="blue")
arrows(model_values, err_cv[,1]-err_cv[,2], model_values, err_cv[,1]+err_cv[,2],
length=0.1, angle=90, code=3)
#dev.off()
}
model_best=model_values[1]
if(run.cv){
model_best <- model_values[which.min(err_cv[,1])]
}
par_best <- list(par=model_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
View(err_cv)
which.min(err_cv[,1])
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
fit_train <- train(dat_train, label_train, par_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par=par_best))
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par=par_best))
par_best$par
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
source('~/Dropbox/Tian_Teaching/G5243-ADS/0-Projects-startercodes/3-Spring2017/Project3_PoodleKFC/lib/train.R')
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
source('~/Dropbox/Tian_Teaching/G5243-ADS/0-Projects-startercodes/3-Spring2017/Project3_PoodleKFC/lib/train.R')
model_best=model_values[1]
if(run.cv){
model_best <- model_values[which.min(err_cv[,1])]
}
par_best <- list(depth=model_best)
tm_train=NA
tm_train <- system.time(fit_train <- train(dat_train, label_train, par_best))
save(fit_train, file="../output/fit_train.RData")
tm_test=NA
if(run.test){
load(file=paste0("../output/feature_", "zip", "_", "test", ".RData"))
load(file="../output/fit_train.RData")
tm_test <- system.time(pred_test <- test(fit_train, dat_test))
save(pred_test, file="../output/pred_test.RData")
}
cat("Time for constructing training features=", tm_feature_train[1], "s \n")
cat("Time for constructing testing features=", tm_feature_test[1], "s \n")
cat("Time for training model=", tm_train[1], "s \n")
cat("Time for making prediction=", tm_test[1], "s \n")
######## Sample codes ##########
stdin = tempfile("test")
cat("1 1\n1 2\n1 3", file = stdin)
stdin
lines=readLines(stdin)
lines
for(l in lines){
if(l == ""){   # no input data
break;      # stop running
}
ll = strsplit(l, " ")[[1]]
a = ll[1];
b = ll[2];
cat(as.numeric(a)+as.numeric(b));
cat("\n");
}
ll = "1 1"
strsplit(ll," ")
strsplit(ll," ")[[1]]
l = strsplit(ll," ")[[1]]
l[1]
l[2]
# About strsplit()
sample_text = "1 1\n2 2\n3 4"
sample_text
# About strsplit()
cat("1 1\n2 2\n3 4")
# About strsplit()
lines
ll = strsplit(lines[1]," ")
ll
ll[[1]]
# About strsplit()
cat("1 1\n1 2\n1 3")
stdin = tempfile("test")
cat("3\n1 2 3\n2 1 3\n3 2 1", file = stdin)
lines = readLines(stdin)
lines
lines
cat("3\n1 2 3\n2 1 3\n3 2 1"ï¼‰
cat("3\n1 2 3\n2 1 3\n3 2 1")
lines
sum = 0
line_count = 0
line_index = 1
for (l in lines){
if(l == ""){
break;
}
if(line_count == 0){  # wether this line refers to the matrix dim n ?
line_count = as.numeric(l); # Yes, we mark the matrix dim as line_count
next                        # Yes, we jump to the next loop, i.e. read the matrix data
}
if(line_index > line_count){  # Are we finish counting all lines in the matrix ?
# Yes, end the whole for loop
break;
}
line_index = line_index + 1   # No, "+1" for the next line evaluation
print(line_index)
ll = strsplit(l, " ")[[1]]   # a single row of the matrix
print(ll)
for (num in ll){   # numbers are still in character mode
sum = sum + as.numeric(num);
}
print(sum)
}
cat(sum)
cat("\n");
stdin = tempfile("test")
cat("3 10\n1 7 12", file = stdin)
cat("3 10\n1 7 12")
lines = readLines(stdin)
lines
ll = strsplit(lines, " ")[[1]]
as.numeric(ll)
ll = strsplit(lines, " ")[[2]]
as.numeric(ll)
for (l in lines){
if(l == ""){
break;
}
if(line.count == 1){
ll = strsplit(l, " ")[[1]]
#print(ll)
n = as.numeric(ll[1]);
a = as.numeric(ll[2]);
print(n)
print(a)
line.count = line.count + 1
next
}
#if(line.count > 2){
# break;
#}
ll = strsplit(l, " ")[[1]]
x = as.numeric(ll)
for (j in 1:n) {
if (count == n-1) {    # we have reached n-1 positions, end race
break;
}
else {
dist = min(abs(a - x)) + dist
position = which.min(abs(a-x))
a = x[position]
x = x[-position]
count = count+1
}
}
}
lines = readLines(stdin)
line.count = 1
count = 0
dist = 0
for (l in lines){
if(l == ""){
break;
}
if(line.count == 1){
ll = strsplit(l, " ")[[1]]
#print(ll)
n = as.numeric(ll[1]);
a = as.numeric(ll[2]);
print(n)
print(a)
line.count = line.count + 1
next
}
#if(line.count > 2){
# break;
#}
ll = strsplit(l, " ")[[1]]
x = as.numeric(ll)
for (j in 1:n) {
if (count == n-1) {    # we have reached n-1 positions, end race
break;
}
else {
dist = min(abs(a - x)) + dist
position = which.min(abs(a-x))
a = x[position]
x = x[-position]
count = count+1
}
}
}
cat("4 12\n2 4 19", file = stdin)
lines = readLines(stdin)
line.count = 1
count = 0
dist = 0
for (l in lines){
if(l == ""){
break;
}
if(line.count == 1){
ll = strsplit(l, " ")[[1]]
#print(ll)
n = as.numeric(ll[1]);
a = as.numeric(ll[2]);
print(n)
print(a)
line.count = line.count + 1
next
}
#if(line.count > 2){
# break;
#}
ll = strsplit(l, " ")[[1]]
x = as.numeric(ll)
for (j in 1:n) {
if (count == n-1) {    # we have reached n-1 positions, end race
break;
}
else {
dist = min(abs(a - x)) + dist
position = which.min(abs(a-x))
a = x[position]
x = x[-position]
count = count+1
}
}
}
cat(dist)
cat("3 10\n1 7 12", file = stdin)
lines = readLines(stdin)
line.count = 1
count = 0
dist = 0
for (l in lines){
if(l == ""){
break;
}
if(line.count == 1){
ll = strsplit(l, " ")[[1]]
#print(ll)
n = as.numeric(ll[1]);
a = as.numeric(ll[2]);
print(n)
print(a)
line.count = line.count + 1
next
}
#if(line.count > 2){
# break;
#}
ll = strsplit(l, " ")[[1]]
x = as.numeric(ll)
for (j in 1:n) {
if (count == n-1) {    # we have reached n-1 positions, end race
break;
}
else {
dist = min(abs(a - x)) + dist
position = which.min(abs(a-x))
a = x[position]
x = x[-position]
count = count+1
}
}
}
cat(dist)
cat("4 12\n2 4 19", file = stdin)
lines = readLines(stdin)
line.count = 1
count = 0
dist = 0
for (l in lines){
if(l == ""){
break;
}
if(line.count == 1){
ll = strsplit(l, " ")[[1]]
#print(ll)
n = as.numeric(ll[1]);
a = as.numeric(ll[2]);
#print(n)
#print(a)
line.count = line.count + 1
next
}
#if(line.count > 2){
# break;
#}
ll = strsplit(l, " ")[[1]]
x = as.numeric(ll)
for (j in 1:n) {
if (count == n-1) {    # we have reached n-1 positions, end race
break;
}
else {
dist = min(abs(a - x)) + dist
position = which.min(abs(a-x))
a = x[position]
x = x[-position]
count = count+1
}
}
}
cat(dist)
cat("\n");
